"""
ADM1 Parameter Calibration using Optuna.

Provides automated calibration of ADM1 kinetic parameters using
Bayesian optimization (TPE algorithm).
"""

import optuna
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Callable
from openad_lib.models.mechanistic import ADM1Model
from openad_lib.utils.metrics import compute_metrics


class ADM1Calibrator:
    """
    Optuna-based calibrator for ADM1 kinetic parameters.
    
    ADM1 has 74+ parameters in total, but most should remain at validated defaults.
    This calibrator focuses on the most sensitive kinetic and yield parameters.
    
    Key Parameters to Calibrate:
    ----------------------------
    Hydrolysis:
        - k_hyd: Hydrolysis rate constant
        
    Uptake rates (k_m):
        - k_m_su: Uptake rate for sugars (default: 30 d^-1)
        - k_m_aa: Uptake rate for amino acids (default: 50 d^-1)
        - k_m_fa: Uptake rate for LCFA (default: 6 d^-1)
        - k_m_c4: Uptake rate for valerate/butyrate (default: 20 d^-1)
        - k_m_pro: Uptake rate for propionate (default: 13 d^-1)
        - k_m_ac: Uptake rate for acetate (default: 8 d^-1)
        - k_m_h2: Uptake rate for hydrogen (default: 35 d^-1)
        
    Half-saturation constants (K_S):
        - K_S_su: Half-saturation for sugars (default: 0.5 kg COD/m³)
        - K_S_aa: Half-saturation for amino acids (default: 0.3 kg COD/m³)
        - K_S_fa: Half-saturation for LCFA (default: 0.4 kg COD/m³)
        - K_S_c4: Half-saturation for valerate/butyrate (default: 0.2 kg COD/m³)
        - K_S_pro: Half-saturation for propionate (default: 0.1 kg COD/m³)
        - K_S_ac: Half-saturation for acetate (default: 0.15 kg COD/m³)
        - K_S_h2: Half-saturation for hydrogen (default: 7e-6 kg COD/m³)
        
    Inhibition constants (K_I):
        - K_I_h2_fa: H2 inhibition on LCFA uptake (default: 5e-6 kmole/m³)
        - K_I_h2_c4: H2 inhibition on valerate/butyrate (default: 1e-5 kmole/m³)
        - K_I_h2_pro: H2 inhibition on propionate (default: 3.5e-6 kmole/m³)
        - K_I_nh3: Free ammonia inhibition (default: 0.0018 kmole N/m³)
        
    Yield coefficients (Y):
        - Y_su: Sugar degraders yield (default: 0.1 kg COD/kg COD)
        - Y_aa: Amino acid degraders yield (default: 0.08 kg COD/kg COD)
        - Y_fa: LCFA degraders yield (default: 0.06 kg COD/kg COD)
        - Y_c4: Valerate/butyrate degraders yield (default: 0.06 kg COD/kg COD)
        - Y_pro: Propionate degraders yield (default: 0.04 kg COD/kg COD)
        - Y_ac: Acetate degraders yield (default: 0.05 kg COD/kg COD)
        - Y_h2: Hydrogen degraders yield (default: 0.06 kg COD/kg COD)
    
    Example
    -------
    >>> from openad_lib.models.mechanistic import ADM1Model
    >>> from openad_lib.optimisation import ADM1Calibrator
    >>> 
    >>> model = ADM1Model()
    >>> calibrator = ADM1Calibrator(model, measurement_data)
    >>> 
    >>> # Define which parameters to calibrate
    >>> param_bounds = {
    >>>     'k_hyd': (0.05, 0.5),
    >>>     'k_m_ac': (5.0, 15.0),
    >>>     'K_S_ac': (0.05, 0.3)
    >>> }
    >>> 
    >>> results = calibrator.calibrate(
    >>>     param_bounds=param_bounds,
    >>>     n_trials=50,
    >>>     target_outputs=['q_ch4']
    >>> )
    """
    
    def __init__(
        self,
        model: ADM1Model,
        measurement_data: pd.DataFrame,
        influent_data: pd.DataFrame
    ):
        """
        Initialize ADM1 calibrator.
        
        Parameters
        ----------
        model : ADM1Model
            ADM1 model instance
        measurement_data : pd.DataFrame
            Measured outputs for calibration (e.g., biogas, VFA)
            Must contain 'time' column and measurement columns
        influent_data : pd.DataFrame
            Influent data generated by ACoD preprocessing
        """
        self.model = model
        self.measurement_data = measurement_data
        self.influent_data = influent_data
        
        # Default parameter bounds (conservative ranges around defaults)
        self.default_bounds = {
            # Hydrolysis
            'k_hyd': (0.05, 0.5),  # Default: 0.1
            
            # Uptake rates (k_m) - ±50% of defaults
            'k_m_su': (15.0, 45.0),   # Default: 30
            'k_m_aa': (25.0, 75.0),   # Default: 50
            'k_m_fa': (3.0, 9.0),     # Default: 6
            'k_m_c4': (10.0, 30.0),   # Default: 20
            'k_m_pro': (6.5, 19.5),   # Default: 13
            'k_m_ac': (4.0, 12.0),    # Default: 8
            'k_m_h2': (17.5, 52.5),   # Default: 35
            
            # Half-saturation constants (K_S)
            'K_S_su': (0.25, 0.75),   # Default: 0.5
            'K_S_aa': (0.15, 0.45),   # Default: 0.3
            'K_S_fa': (0.2, 0.6),     # Default: 0.4
            'K_S_c4': (0.1, 0.3),     # Default: 0.2
            'K_S_pro': (0.05, 0.15),  # Default: 0.1
            'K_S_ac': (0.075, 0.225), # Default: 0.15
            'K_S_h2': (3.5e-6, 1e-5), # Default: 7e-6
            
            # Inhibition constants (K_I)
            'K_I_h2_fa': (2.5e-6, 7.5e-6),  # Default: 5e-6
            'K_I_h2_c4': (5e-6, 1.5e-5),    # Default: 1e-5
            'K_I_h2_pro': (1.75e-6, 5.25e-6), # Default: 3.5e-6
            'K_I_nh3': (0.0009, 0.0027),    # Default: 0.0018
            
            # Yield coefficients (Y) - narrower bounds for mass conservation
            'Y_su': (0.05, 0.15),     # Default: 0.1
            'Y_aa': (0.04, 0.12),     # Default: 0.08
            'Y_fa': (0.03, 0.09),     # Default: 0.06
            'Y_c4': (0.03, 0.09),     # Default: 0.06
            'Y_pro': (0.02, 0.06),    # Default: 0.04
            'Y_ac': (0.025, 0.075),   # Default: 0.05
            'Y_h2': (0.03, 0.09),     # Default: 0.06
        }
    
    def calibrate(
        self,
        param_bounds: Optional[Dict[str, tuple]] = None,
        n_trials: int = 100,
        target_outputs: List[str] = ['q_ch4'],
        objective_metric: str = 'rmse',
        show_progress: bool = True,
        n_jobs: int = 1
    ) -> Dict:
        """
        Calibrate ADM1 parameters using Optuna.
        
        Parameters
        ----------
        param_bounds : dict, optional
            Dictionary of parameter bounds {param_name: (min, max)}.
            If None, calibrates a subset of sensitive parameters.
        n_trials : int, default=100
            Number of optimization trials
        target_outputs : list, default=['q_ch4']
            Output variables to match. Options:
            - 'q_ch4': Methane flow
            - 'q_gas': Total biogas
            - 'S_ac': Acetate concentration
            - 'S_pro': Propionate concentration
            - 'S_h2': Hydrogen concentration
        objective_metric : str, default='rmse'
            Metric to minimize: 'rmse', 'mae', 'nmse'
        show_progress : bool, default=True
            Show optimization progress bar
        n_jobs : int, default=1
            Number of  parallel jobs (-1 for all cores)
            
        Returns
        -------
        results : dict
            Dictionary with:
            - 'best_params': Optimized parameters
            - 'best_value': Final objective value
            - 'study': Full Optuna study object
            - 'metrics': Evaluation metrics with best parameters
        """
        if param_bounds is None:
            # Default: calibrate most sensitive parameters
            param_bounds = {
                'k_hyd': self.default_bounds['k_hyd'],
                'k_m_ac': self.default_bounds['k_m_ac'],
                'K_S_ac': self.default_bounds['K_S_ac'],
                'k_m_h2': self.default_bounds['k_m_h2'],
                'K_I_nh3': self.default_bounds['K_I_nh3']
            }
        
        self.param_bounds = param_bounds
        self.target_outputs = target_outputs
        self.objective_metric = objective_metric
        
        # Create Optuna study
        study = optuna.create_study(
            direction='minimize',
            sampler=optuna.samplers.TPESampler(seed=42)
        )
        
        # Run optimization
        study.optimize(
            self._objective,
            n_trials=n_trials,
            show_progress_bar=show_progress,
            n_jobs=n_jobs
        )
        
        # Evaluate with best parameters
        best_params = study.best_params
        self._apply_params(best_params)
        sim_results = self.model.simulate(self.influent_data)
        
        # Compute detailed metrics
        metrics = {}
        for output in target_outputs:
            if output in self.measurement_data.columns:
                y_true = self.measurement_data[output].values
                y_pred = self._extract_output(sim_results, output)
                
                # Align lengths
                min_len = min(len(y_true), len(y_pred))
                y_true = y_true[:min_len]
                y_pred = y_pred[:min_len]
                
                output_metrics = compute_metrics(y_true, y_pred)
                for metric_name, value in output_metrics.items():
                    metrics[f'{output}_{metric_name}'] = value
        
        return {
            'best_params': best_params,
            'best_value': study.best_value,
            'study': study,
            'metrics': metrics,
            'simulation_results': sim_results
        }
    
    def _objective(self, trial: optuna.Trial) -> float:
        """
        Objective function for Optuna optimization.
        
        Parameters
        ----------
        trial : optuna.Trial
            Optuna trial object
            
        Returns
        -------
        objective_value : float
            Metric value to minimize
        """
        # Sample parameters
        params = {}
        for param_name, (min_val, max_val) in self.param_bounds.items():
            params[param_name] = trial.suggest_float(param_name, min_val, max_val)
        
        # Apply parameters to model
        # Note: ADM1Model doesn't have update_params yet, so we modify directly
        # TODO: Update when ADM1Model inherits from MechanisticModel
        self._apply_params(params)
        
        # Run simulation
        try:
            sim_results = self.model.simulate(self.influent_data)
        except Exception as e:
            # If simulation fails, return large penalty
            print(f"Simulation failed: {e}")
            return 1e10
        
        # Compute objective
        total_error = 0
        n_outputs = 0
        
        for output in self.target_outputs:
            if output not in self.measurement_data.columns:
                continue
            
            y_true = self.measurement_data[output].values
            y_pred = self._extract_output(sim_results, output)
            
            # Align lengths
            min_len = min(len(y_true), len(y_pred))
            y_true = y_true[:min_len]
            y_pred = y_pred[:min_len]
            
            # Remove NaN
            mask = ~(np.isnan(y_true) | np.isnan(y_pred))
            if mask.sum() == 0:
                continue
            
            y_true = y_true[mask]
            y_pred = y_pred[mask]
            
            # Compute metric
            if self.objective_metric == 'rmse':
                error = np.sqrt(np.mean((y_true - y_pred)**2))
            elif self.objective_metric == 'mae':
                error = np.mean(np.abs(y_true - y_pred))
            elif self.objective_metric == 'nmse':
                error = np.mean((y_true - y_pred)**2) / np.var(y_true)
            else:
                raise ValueError(f"Unknown metric: {self.objective_metric}")
            
            total_error += error
            n_outputs += 1
        
        return total_error / max(n_outputs, 1)
    
    def _apply_params(self, params: Dict[str, float]):
        """Apply parameters to ADM1 model."""
        # This is a placeholder - actual implementation depends on ADM1Model structure
        # For now, we'd need to modify the Param list or ODE coefficients
        # TODO: Implement proper parameter update mechanism in ADM1Model
        
        # Temporary: Store params for later ODE modification
        # In practice, this would update the model's internal parameter structure
        if not hasattr(self.model, '_calibrated_params'):
            self.model._calibrated_params = {}
        self.model._calibrated_params.update(params)
    
    def _extract_output(self, sim_results: Dict, output_name: str) -> np.ndarray:
        """
        Extract output variable from simulation results.
        
        Parameters
        ----------
        sim_results : dict
            Simulation results from ADM1Model.simulate()
        output_name : str
            Output variable name
            
        Returns
        -------
        values : np.ndarray
            Output values
        """
        if output_name == 'q_ch4':
            return sim_results['q_ch4']['q_ch4'].values
        elif output_name == 'q_gas':
            return sim_results['q_gas']['q_gas'].values
        elif output_name in sim_results['results'].columns:
            return sim_results['results'][output_name].values
        else:
            raise ValueError(f"Unknown output: {output_name}")


__all__ = ['ADM1Calibrator']
