
import numpy as np
import pandas as pd
from scipy.integrate import solve_ivp
from openad_lib.models.mechanistic.adm1_components import ode, inputs, initial

class ADM1Model:
    """
    ADM1 Model implementation wrapping the detailed ODE definitions.
    """
    def __init__(self):
        # Constant definition from the Rosen et al (2006) BSM2 report
        self.R = 0.083145                                                                # bar.M^-1.K^-1, Gas constant
        self.T_base = 298.15                                                             # K, Base temperature
        self.T_op = 318.15                                                               # K, Operating temperature (= 35 C)
        self.k_p = 20000
        self.p_atm = 1.013                                                               # Atmospheric pressure in bar
        self.p_gas_h2o = 0.0313 * np.exp(5290 * (1 / self.T_base - 1 / self.T_op))       # Water vapor pressure in gas
        self.k_hyd = 0.1                                                                 # Hydrolysis constant
        
        self.Param = [self.R, self.T_base, self.T_op, self.k_p, self.p_atm, self.p_gas_h2o, self.k_hyd]
        
        self.V_liq = 10195 # m^3
        self.V_gas = 600   # m^3

    def set_parameters(self, **kwargs):
        """
        Update model parameters. 
        Currently supports updating basic constants if needed, but primary params are in Param list.
        """
        # This is a placeholder for more advanced parameter setting if required
        pass

    def simulate(self, influent_data: pd.DataFrame, initial_conditions=None, t_eval=None):
        """
        Run the ADM1 simulation.
        
        Args:
            influent_data: DataFrame containing input state variables. 
                           Must contain columns like 'S_su', 'S_aa', etc. (generated by ACoD).
            initial_conditions: Optional list of initial state values (35 variables).
                                Defaults to values in adm1_components.initial.
            t_eval: Optional time points. Currently the simulation steps are determined by influent data rows.
            
        Returns:
            dict: {
                'results': DataFrame of state variables over time,
                'q_gas': DataFrame of gas flows,
                'q_ch4': DataFrame of methane flows
            }
        """
        
        # Initial Setup
        if initial_conditions is None:
            CI = initial.CI
        else:
            CI = initial_conditions
            
        # Initial condition of the system
        x0 = np.array(CI)
        
        # Results container
        columns_res = [
            "S_su", "S_aa", "S_fa", "S_va", "S_bu", "S_pro", "S_ac", "S_h2", "S_ch4",
            "S_IC", "S_IN", "S_I", "X_xc", "X_ch", "X_pr", "X_li", "X_su", "X_aa",
            "X_fa", "X_c4", "X_pro", "X_ac", "X_h2", "X_I", "S_cation", "S_anion",
            "S_va_ion", "S_bu_ion", "S_pro_ion", "S_ac_ion", "S_hco3_ion", "S_nh3", "S_gas_h2",
            "S_gas_ch4", "S_gas_co2"
        ]
        
        simulate_results = [x0]
        q_gas_list = []
        q_ch4_list = []
        
        # Calculate initial gas flow (just for consistency, usually 0 or based on initial state)
        # Using logic from loop for first step
        Sgas_h2_0, Sgas_ch4_0, Sgas_co2_0 = x0[32], x0[33], x0[34]
        p_gas_h2 = Sgas_h2_0 * self.R * self.T_op / 16
        p_gas_ch4 = Sgas_ch4_0 * self.R * self.T_op / 64
        p_gas_co2 = Sgas_co2_0 * self.R * self.T_op
        p_gas = p_gas_h2 + p_gas_ch4 + p_gas_co2 + self.p_gas_h2o
        q_gas = (self.k_p * (p_gas - self.p_atm)) * p_gas / self.p_atm
        q_ch4 = q_gas * (p_gas_ch4 / p_gas) if p_gas > 0 else 0
        
        q_gas_list.append(q_gas)
        q_ch4_list.append(q_ch4)
        
        # Time setup
        if 'time' in influent_data.columns:
            t = influent_data['time'].values
        else:
            t = np.arange(len(influent_data))
            
        t0 = t[0] if len(t) > 0 else 0
        
        print(f"Starting simulation for {len(t)-1} steps...")
        
        # Simulation Loop
        # Loop for simulating at each time step and feeding the results to the next time step
        # Note: The original code iterates u in t[0:600], but actually acts on intervals.
        # We assume influent_data row i corresponds to input during interval [t_i, t_{i+1}]
        
        for i in range(len(t) - 1): # Iterate intervals
            u = t[i+1] # End time of step
            
            # Helper to print progress
            if i % 50 == 0:
                print(f'Day: {t0}')

            # Influent characterization for this step
            # Note: input_variables_ADM1 takes index i.
            # We need to ensure influent_data index is aligned.
            # Resetting index to integer if needed or just using iloc logic inside inputs?
            # Creating a dummy object that supports ['col'][i] access pattern or modifying inputs.py?
            # inputs.py uses: influent_state['S_su'][i]
            # If influent_data is a DataFrame, this works if column access returns Series and i is valid index.
            # BUT if loop index 'i' doesn't match DF index (e.g. if time is 1,2,3...), we should be careful.
            # Let's trust the user data structure has 0-based integer index or 'i' matches.
            
            try:
                yin = inputs.input_variables_ADM1(influent_data, i)
            except KeyError as e:
                # Fallback if accessed by integer position but index is time
                # We can construct a row-based dict or similar
                # But inputs function is hardcoded to use [i].
                # Let's assume influent_data is proper.
                raise e

            # Integration
            # solve_ivp(fun, t_span, y0, method='BDF', args=None, ...)
            sol = solve_ivp(
                ode.ADM1_ode, 
                t_span=(t0, u), 
                y0=x0, 
                method='BDF', 
                args=[yin, self.V_liq, self.V_gas, self.Param], 
                rtol=1e-5, 
                atol=1e-6
            )
            
            # Update state for next step
            x0 = sol.y[:,-1] 
            t0 = u
            
            # Store results
            simulate_results.append(x0)
            
            # Calculate Gas Flows for Storage
            p_gas_h2 = x0[32] * self.R * self.T_op / 16
            p_gas_ch4 = x0[33] * self.R * self.T_op / 64
            p_gas_co2 = x0[34] * self.R * self.T_op
            p_gas = p_gas_h2 + p_gas_ch4 + p_gas_co2 + self.p_gas_h2o
            q_gas = max(0, (self.k_p * (p_gas - self.p_atm)) * p_gas / self.p_atm)
            q_ch4 = q_gas * (p_gas_ch4 / p_gas) if p_gas > 0 else 0
            
            q_gas_list.append(q_gas)
            q_ch4_list.append(q_ch4)

        # Formatting Output
        df_res = pd.DataFrame(simulate_results, columns=columns_res)
        df_qgas = pd.DataFrame(q_gas_list, columns=["q_gas"])
        df_qch4 = pd.DataFrame(q_ch4_list, columns=["q_ch4"])
        
        # Align lengths if mismatched (initial condition adds 1 row, loop adds N-1 rows => N rows total)
        # Time vector t has N elements.
        df_res['time'] = t[:len(df_res)]
        df_qgas['time'] = t[:len(df_qgas)]
        df_qch4['time'] = t[:len(df_qch4)]
        
        return {
            'results': df_res,
            'q_gas': df_qgas,
            'q_ch4': df_qch4
        }
